
input AMPLIFY { globalAuthRule: AuthRule = { allow: public } }


type Location {   
  lat: Float!   
  lon: Float! 
}

type User 
@model
@auth(
  rules: [
    { allow: owner, operations: [read, create, update, delete] }, 
    { allow: groups, groups: ["admin"], operations: [create, update, delete] },
    { allow: private, operations: [read, create, update, delete] },

    ## TODO: We want to remove this, but currently the lambda permissions hate us
    { allow: public, operations: [read, update] }
  ]
) {
  id: ID!
  firstName: String!
  lastName: String!
  availableBalance: Float
  pendingBalance: Float

  tippingActive: Boolean
  unreadNotifications: Boolean

  backgroundImage: ImagePath @hasOne
  profileImage: ImagePath @hasOne
  establishments: [EstablishmentTibi] @hasMany(indexName: "byUser", fields: ["id"])

  location: Location


  occupations: [Occupation] @hasMany(indexName: "byUser", fields: ["id"])
  activeOccupation: Occupation @hasOne
}

type Device
@model
@auth(
  rules: [
    { allow: owner, operations: [read, create, update, delete] }, 
    { allow: groups, groups: ["admin"], operations: [create, update, delete] }, 
    { allow: private, operations: [read, create, update, delete] },
    { allow: public, operations: [read] }
  ]
) {
  id: ID!
  name: String!
  token: String!

  userId: ID!
}

enum ImageLocation {
  system
  assets
  remote
  s3
}

enum EstablishmentType {
  hotel
  custom
}

type ImagePath @model 
@auth(
  rules: [
    { allow: owner, operations: [read, create, update, delete] }, 
    { allow: groups, groups: ["admin"], operations: [create, update, delete] }, 
    { allow: private, operations: [read, create, update, delete] },
    { allow: public, operations: [read] }
  ]
) {
  key: String!
  location: ImageLocation!
}

type Occupation 
@model 
@auth(
  rules: [
    { allow: owner, operations: [read, create, update, delete] }, 
    { allow: groups, groups: ["admin"], operations: [create, update, delete] }, 
    { allow: private, operations: [read] },
    { allow: public, operations: [read] }
  ]
) {
  id: ID!

  name: String!
  backgroundImage: ImagePath! @hasOne

  ## If supplied this occupation is only for this establishment
  establishmentId: ID @index(name: "byEstablishment", sortKeyFields: ["name"])

  userId: ID @index(name: "byUser", sortKeyFields: ["name"])
}

type Establishment 
@model
@auth(
  rules: [
    { allow: owner, operations: [read, create, update, delete] }, 
    { allow: groups, groups: ["admin"], operations: [read, create, update, delete] }, 
    { allow: private, operations: [read] },
    { allow: public, operations: [read] }
  ]
) {
  id: ID!
  name: String!
  type: EstablishmentType!
  image: ImagePath @hasOne
  website: AWSURL
  tibis: [EstablishmentTibi] @hasMany(indexName: "byEstablishment", fields: ["id"])
  occupations: [Occupation] @hasMany(indexName: "byEstablishment", fields: ["id"])
}

type EstablishmentTibi 
@model 
@auth(
  rules: [
    { allow: owner, operations: [read, create, update, delete] }, 
    { allow: groups, groups: ["admin"], operations: [read, create, update, delete] },
    { allow: private, operations: [read, create] },
    { allow: public, operations: [read, create] }
  ]
) {
  id: ID!
  userId: ID! @index(name: "byUser", sortKeyFields: ["establishmentId"])
  establishmentId: ID! @index(name: "byEstablishment", queryField: "usersByEstablishment")
  establishment: Establishment! @belongsTo(fields: ["establishmentId"])
  user: User! @belongsTo(fields: ["userId"])

  roles: [String]!
}

enum PaymentType {
  credit
  debit
  applePay
  crypto
}

type Wallet 
@model 
@auth(
  rules: [
    { allow: owner, operations: [read, create, update, delete] }, 
    { allow: groups, groups: ["admin"], operations: [create, update, delete] }, 
    { allow: private, operations: [read, create, update, delete] },
    { allow: public, operations: [read] }
  ]
) {
  id: ID!
  cryptoHash: String
  cryptoBalance: String
  payments: [Payment] @hasMany(indexName: "byWallet", fields: ["id"])
}

enum TransactionStatus {
  pending
  complete
  refunded
}

type Payment @model 
@auth(
  rules: [
    { allow: private, operations: [read, create, update, delete] },
    { allow: private, provider: iam, operations: [read, create, update, delete] }

    ## TODO: We want to remove this, but currently the lambda permissions hate us
    { allow: public, operations: [read, update] }
  ]
) {
  id: ID!
  walletId: ID! @index(name: "byWallet")
  name: String
  fee: Float
  isDefault: Boolean
  type: PaymentType
  description: String
  token: String
}

enum TransactionRating {
  good
  great
  awesome
}

type Transaction
@model
@searchable
@auth(
  rules: [
    { allow: private, operations: [read, create, update, delete] },
    { allow: private, provider: iam, operations: [read, create, update, delete] }

    ## TODO: We want to remove this, but currently the lambda permissions hate us
    { allow: public, operations: [read, update] }
  ]
) {

  ## TODO: Remove this primaryKey thing
  id: ID!
  amount: Float
  status: TransactionStatus

  createdAt: AWSDateTime!

  transactionPaymentId: ID!
  transactionSourceId: ID!
  transactionDestinationId: ID!

  rating: TransactionRating

  payment: Payment! @hasOne(fields: ["transactionPaymentId"])
  source: User! @hasOne(fields: ["transactionSourceId"])
  destination: User! @hasOne(fields: ["transactionDestinationId"])
}


enum NotificationType {
  tip
  system
  newMessage
}

type Notification 
@searchable
@model
@auth(
  rules: [
    { allow: private, operations: [read, create, update, delete] },
    { allow: private, provider: iam, operations: [read, create, update, delete] }

    ## TODO: We want to remove this, but currently the lambda permissions hate us
    { allow: public, operations: [read, create] }
  ]
) {
  id: ID!

  userId: ID! @index(name: "byUser", queryField: "byUser")   ## User ID for this notification
  type: NotificationType!
  expirationDate: AWSDateTime

  title: String!
  details: String!

  read: Boolean

  ## Extra metadata associated with this notification
  fromUserId: ID ## If the data is from a given user this will be populated

}

 